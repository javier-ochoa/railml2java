//
// This file was generated by the Eclipse Implementation of JAXB, v3.0.0 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2023.05.25 at 11:54:17 AM EEST 
//


package railml;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import javax.xml.datatype.Duration;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlType;


/**
 * INESS (INtegrated European Signalling System) definition: A defined section of track in advance of a stop signal, or a stopping point in a continuous signalling system, which must be kept clear to avoid the risk of collision should a train inadvertently run past the signal or the stopping point.
 * Many IMs require overlap beyond active routes to protect from overshoot. One or more sections beyond the exit signal are locked out from use by other routes. The overlap is delimited by train detectors. Facing switches in the overlap are locked, otherwise, use the swinging overlap. Trailing switches in the overlap may normally not locked. Note that there is no need to explicitly identify the switches in the overlap because they can be derived from the begin and endpoints of the overlap.
 * The overlap can be released if the RBC deems that an approaching train is slow enough such that overshoot is unlikely.
 * Trains other than the one for which the route-overlap is locked may be attributed a permitted speed in the overlap. If the value is set to 0 it is not possible to set a route through the overlap. Compare this variable with the release speed that applies to the train that is being released beyond the danger point.
 * 
 * <p>Java class for Overlap complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Overlap"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{https://www.railml.org/schemas/3.2}RouteObject"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="activeForApproachRoute" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="relatedToTrackAsset" type="{https://www.railml.org/schemas/3.2}EntityILref" minOccurs="0"/&gt;
 *         &lt;element name="requiresSwitchInPosition" type="{https://www.railml.org/schemas/3.2}SwitchAndGivenPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="requiresLevelCrossingInState" type="{https://www.railml.org/schemas/3.2}LevelCrossingAndGivenState" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="hasTvdSection" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="isLimitedBy" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="overlapRelease" type="{https://www.railml.org/schemas/3.2}OverlapRelease" minOccurs="0"/&gt;
 *         &lt;element name="additionalRelation" type="{https://www.railml.org/schemas/3.2}RelationReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="releaseSpeed" type="{https://www.railml.org/schemas/3.2}tSpeedKmPerHour" /&gt;
 *       &lt;attribute name="overlapSpeed" type="{https://www.railml.org/schemas/3.2}tSpeedKmPerHour" /&gt;
 *       &lt;attribute name="overlapValidityTime" type="{http://www.w3.org/2001/XMLSchema}duration" /&gt;
 *       &lt;attribute name="length" type="{https://www.railml.org/schemas/3.2}tLengthM" /&gt;
 *       &lt;anyAttribute namespace='##other'/&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Overlap", propOrder = {
    "activeForApproachRoute",
    "relatedToTrackAsset",
    "requiresSwitchInPosition",
    "requiresLevelCrossingInState",
    "hasTvdSection",
    "isLimitedBy",
    "overlapRelease",
    "additionalRelation"
})
public class Overlap
    extends RouteObject
{

    protected List<EntityILref> activeForApproachRoute;
    protected EntityILref relatedToTrackAsset;
    protected List<SwitchAndGivenPosition> requiresSwitchInPosition;
    protected List<LevelCrossingAndGivenState> requiresLevelCrossingInState;
    protected List<EntityILref> hasTvdSection;
    protected List<EntityILref> isLimitedBy;
    protected OverlapRelease overlapRelease;
    protected List<RelationReference> additionalRelation;
    @XmlAttribute(name = "releaseSpeed")
    protected BigDecimal releaseSpeed;
    @XmlAttribute(name = "overlapSpeed")
    protected BigDecimal overlapSpeed;
    @XmlAttribute(name = "overlapValidityTime")
    protected Duration overlapValidityTime;
    @XmlAttribute(name = "length")
    protected BigDecimal length;

    /**
     * Gets the value of the activeForApproachRoute property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the activeForApproachRoute property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getActiveForApproachRoute().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getActiveForApproachRoute() {
        if (activeForApproachRoute == null) {
            activeForApproachRoute = new ArrayList<EntityILref>();
        }
        return this.activeForApproachRoute;
    }

    /**
     * Gets the value of the relatedToTrackAsset property.
     * 
     * @return
     *     possible object is
     *     {@link EntityILref }
     *     
     */
    public EntityILref getRelatedToTrackAsset() {
        return relatedToTrackAsset;
    }

    /**
     * Sets the value of the relatedToTrackAsset property.
     * 
     * @param value
     *     allowed object is
     *     {@link EntityILref }
     *     
     */
    public void setRelatedToTrackAsset(EntityILref value) {
        this.relatedToTrackAsset = value;
    }

    /**
     * Gets the value of the requiresSwitchInPosition property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the requiresSwitchInPosition property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRequiresSwitchInPosition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SwitchAndGivenPosition }
     * 
     * 
     */
    public List<SwitchAndGivenPosition> getRequiresSwitchInPosition() {
        if (requiresSwitchInPosition == null) {
            requiresSwitchInPosition = new ArrayList<SwitchAndGivenPosition>();
        }
        return this.requiresSwitchInPosition;
    }

    /**
     * Gets the value of the requiresLevelCrossingInState property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the requiresLevelCrossingInState property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRequiresLevelCrossingInState().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LevelCrossingAndGivenState }
     * 
     * 
     */
    public List<LevelCrossingAndGivenState> getRequiresLevelCrossingInState() {
        if (requiresLevelCrossingInState == null) {
            requiresLevelCrossingInState = new ArrayList<LevelCrossingAndGivenState>();
        }
        return this.requiresLevelCrossingInState;
    }

    /**
     * Gets the value of the hasTvdSection property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the hasTvdSection property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasTvdSection().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getHasTvdSection() {
        if (hasTvdSection == null) {
            hasTvdSection = new ArrayList<EntityILref>();
        }
        return this.hasTvdSection;
    }

    /**
     * Gets the value of the isLimitedBy property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the isLimitedBy property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIsLimitedBy().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getIsLimitedBy() {
        if (isLimitedBy == null) {
            isLimitedBy = new ArrayList<EntityILref>();
        }
        return this.isLimitedBy;
    }

    /**
     * Gets the value of the overlapRelease property.
     * 
     * @return
     *     possible object is
     *     {@link OverlapRelease }
     *     
     */
    public OverlapRelease getOverlapRelease() {
        return overlapRelease;
    }

    /**
     * Sets the value of the overlapRelease property.
     * 
     * @param value
     *     allowed object is
     *     {@link OverlapRelease }
     *     
     */
    public void setOverlapRelease(OverlapRelease value) {
        this.overlapRelease = value;
    }

    /**
     * Gets the value of the additionalRelation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the additionalRelation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAdditionalRelation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationReference }
     * 
     * 
     */
    public List<RelationReference> getAdditionalRelation() {
        if (additionalRelation == null) {
            additionalRelation = new ArrayList<RelationReference>();
        }
        return this.additionalRelation;
    }

    /**
     * Gets the value of the releaseSpeed property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */
    public BigDecimal getReleaseSpeed() {
        return releaseSpeed;
    }

    /**
     * Sets the value of the releaseSpeed property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */
    public void setReleaseSpeed(BigDecimal value) {
        this.releaseSpeed = value;
    }

    /**
     * Gets the value of the overlapSpeed property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */
    public BigDecimal getOverlapSpeed() {
        return overlapSpeed;
    }

    /**
     * Sets the value of the overlapSpeed property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */
    public void setOverlapSpeed(BigDecimal value) {
        this.overlapSpeed = value;
    }

    /**
     * Gets the value of the overlapValidityTime property.
     * 
     * @return
     *     possible object is
     *     {@link Duration }
     *     
     */
    public Duration getOverlapValidityTime() {
        return overlapValidityTime;
    }

    /**
     * Sets the value of the overlapValidityTime property.
     * 
     * @param value
     *     allowed object is
     *     {@link Duration }
     *     
     */
    public void setOverlapValidityTime(Duration value) {
        this.overlapValidityTime = value;
    }

    /**
     * Gets the value of the length property.
     * 
     * @return
     *     possible object is
     *     {@link BigDecimal }
     *     
     */
    public BigDecimal getLength() {
        return length;
    }

    /**
     * Sets the value of the length property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigDecimal }
     *     
     */
    public void setLength(BigDecimal value) {
        this.length = value;
    }

}
