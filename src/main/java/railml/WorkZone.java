//
// This file was generated by the Eclipse Implementation of JAXB, v3.0.0 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2023.05.25 at 11:54:17 AM EEST 
//


package railml;

import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlType;


/**
 * A set of track assets that track workers or the signalman can set apart from the main line. When taken, it is impossible to call regular routes into this work zone.
 * 
 * <p>Java class for WorkZone complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="WorkZone"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{https://www.railml.org/schemas/3.2}RestrictedArea"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="activationLock" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="switchInPosition" type="{https://www.railml.org/schemas/3.2}SwitchInPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="derailerInPosition" type="{https://www.railml.org/schemas/3.2}DerailerInPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="crossingInPosition" type="{https://www.railml.org/schemas/3.2}CrossingInPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="detectorInState" type="{https://www.railml.org/schemas/3.2}DetectorInState" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="signalWithAspect" type="{https://www.railml.org/schemas/3.2}SignalWithAspect" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="keyLockInState" type="{https://www.railml.org/schemas/3.2}KeyLockInState" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="levelCrossingInState" type="{https://www.railml.org/schemas/3.2}LevelCrossingInState" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="releasedForLocalOperation" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;anyAttribute namespace='##other'/&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "WorkZone", propOrder = {
    "activationLock",
    "switchInPosition",
    "derailerInPosition",
    "crossingInPosition",
    "detectorInState",
    "signalWithAspect",
    "keyLockInState",
    "levelCrossingInState",
    "releasedForLocalOperation"
})
public class WorkZone
    extends RestrictedArea
{

    protected List<EntityILref> activationLock;
    protected List<SwitchInPosition> switchInPosition;
    protected List<DerailerInPosition> derailerInPosition;
    protected List<CrossingInPosition> crossingInPosition;
    protected List<DetectorInState> detectorInState;
    protected List<SignalWithAspect> signalWithAspect;
    protected List<KeyLockInState> keyLockInState;
    protected List<LevelCrossingInState> levelCrossingInState;
    protected List<EntityILref> releasedForLocalOperation;

    /**
     * Gets the value of the activationLock property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the activationLock property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getActivationLock().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getActivationLock() {
        if (activationLock == null) {
            activationLock = new ArrayList<EntityILref>();
        }
        return this.activationLock;
    }

    /**
     * Gets the value of the switchInPosition property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the switchInPosition property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSwitchInPosition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SwitchInPosition }
     * 
     * 
     */
    public List<SwitchInPosition> getSwitchInPosition() {
        if (switchInPosition == null) {
            switchInPosition = new ArrayList<SwitchInPosition>();
        }
        return this.switchInPosition;
    }

    /**
     * Gets the value of the derailerInPosition property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the derailerInPosition property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDerailerInPosition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DerailerInPosition }
     * 
     * 
     */
    public List<DerailerInPosition> getDerailerInPosition() {
        if (derailerInPosition == null) {
            derailerInPosition = new ArrayList<DerailerInPosition>();
        }
        return this.derailerInPosition;
    }

    /**
     * Gets the value of the crossingInPosition property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the crossingInPosition property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCrossingInPosition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CrossingInPosition }
     * 
     * 
     */
    public List<CrossingInPosition> getCrossingInPosition() {
        if (crossingInPosition == null) {
            crossingInPosition = new ArrayList<CrossingInPosition>();
        }
        return this.crossingInPosition;
    }

    /**
     * Gets the value of the detectorInState property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the detectorInState property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDetectorInState().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DetectorInState }
     * 
     * 
     */
    public List<DetectorInState> getDetectorInState() {
        if (detectorInState == null) {
            detectorInState = new ArrayList<DetectorInState>();
        }
        return this.detectorInState;
    }

    /**
     * Gets the value of the signalWithAspect property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the signalWithAspect property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSignalWithAspect().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SignalWithAspect }
     * 
     * 
     */
    public List<SignalWithAspect> getSignalWithAspect() {
        if (signalWithAspect == null) {
            signalWithAspect = new ArrayList<SignalWithAspect>();
        }
        return this.signalWithAspect;
    }

    /**
     * Gets the value of the keyLockInState property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the keyLockInState property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getKeyLockInState().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link KeyLockInState }
     * 
     * 
     */
    public List<KeyLockInState> getKeyLockInState() {
        if (keyLockInState == null) {
            keyLockInState = new ArrayList<KeyLockInState>();
        }
        return this.keyLockInState;
    }

    /**
     * Gets the value of the levelCrossingInState property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the levelCrossingInState property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLevelCrossingInState().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LevelCrossingInState }
     * 
     * 
     */
    public List<LevelCrossingInState> getLevelCrossingInState() {
        if (levelCrossingInState == null) {
            levelCrossingInState = new ArrayList<LevelCrossingInState>();
        }
        return this.levelCrossingInState;
    }

    /**
     * Gets the value of the releasedForLocalOperation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the releasedForLocalOperation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getReleasedForLocalOperation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getReleasedForLocalOperation() {
        if (releasedForLocalOperation == null) {
            releasedForLocalOperation = new ArrayList<EntityILref>();
        }
        return this.releasedForLocalOperation;
    }

}
