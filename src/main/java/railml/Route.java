//
// This file was generated by the Eclipse Implementation of JAXB, v3.0.0 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2023.05.25 at 11:54:17 AM EEST 
//


package railml;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javax.xml.datatype.Duration;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlType;


/**
 * We define a route as an entry- and exit plus the positions of intermediate switches. If there are no switches in the route, no switch positions can be defined. If one or more switches are encountered en route, either facing or trailing, the positions of these switches must be given. There can be multiple routes from entry to exit depending on the positions of the intermediate switches. The user is free to create different routes with the same entry,exit and same switch positions that differ only by the classifier. This allows one to distinguish for example a traction-route from no-traction-route
 * 
 * <p>Java class for Route complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="Route"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{https://www.railml.org/schemas/3.2}RouteObject"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="handlesRouteType" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="routeActivationSection" type="{https://www.railml.org/schemas/3.2}RouteActivationSection" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="facingSwitchInPosition" type="{https://www.railml.org/schemas/3.2}SwitchAndPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="trailingSwitchInPosition" type="{https://www.railml.org/schemas/3.2}SwitchAndPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="hasTvdSection" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="routeEntry" type="{https://www.railml.org/schemas/3.2}RouteEntry"/&gt;
 *         &lt;element name="intermediateCodePoint" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="hasReleaseGroup" type="{https://www.railml.org/schemas/3.2}EntityILref" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="switchPositionInDepartureTrack" type="{https://www.railml.org/schemas/3.2}SwitchAndPosition" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="routeExit" type="{https://www.railml.org/schemas/3.2}RouteExit"/&gt;
 *         &lt;element name="additionalRelation" type="{https://www.railml.org/schemas/3.2}RelationReference" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="locksAutomatically" type="{http://www.w3.org/2001/XMLSchema}boolean" /&gt;
 *       &lt;attribute name="processingDelay" type="{http://www.w3.org/2001/XMLSchema}duration" /&gt;
 *       &lt;attribute name="proceedAspectDelay" type="{http://www.w3.org/2001/XMLSchema}duration" /&gt;
 *       &lt;attribute name="signalClosureDelay" type="{http://www.w3.org/2001/XMLSchema}duration" /&gt;
 *       &lt;attribute name="approachReleaseDelay" type="{http://www.w3.org/2001/XMLSchema}duration" /&gt;
 *       &lt;attribute name="residualRouteReleaseDelay" type="{http://www.w3.org/2001/XMLSchema}duration" /&gt;
 *       &lt;attribute name="priorityRank" type="{https://www.railml.org/schemas/3.2}tPriority" /&gt;
 *       &lt;anyAttribute namespace='##other'/&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Route", propOrder = {
    "handlesRouteType",
    "routeActivationSection",
    "facingSwitchInPosition",
    "trailingSwitchInPosition",
    "hasTvdSection",
    "routeEntry",
    "intermediateCodePoint",
    "hasReleaseGroup",
    "switchPositionInDepartureTrack",
    "routeExit",
    "additionalRelation"
})
public class Route
    extends RouteObject
{

    protected List<EntityILref> handlesRouteType;
    protected List<RouteActivationSection> routeActivationSection;
    protected List<SwitchAndPosition> facingSwitchInPosition;
    protected List<SwitchAndPosition> trailingSwitchInPosition;
    protected List<EntityILref> hasTvdSection;
    @XmlElement(required = true)
    protected RouteEntry routeEntry;
    protected List<EntityILref> intermediateCodePoint;
    protected List<EntityILref> hasReleaseGroup;
    protected List<SwitchAndPosition> switchPositionInDepartureTrack;
    @XmlElement(required = true)
    protected RouteExit routeExit;
    protected List<RelationReference> additionalRelation;
    @XmlAttribute(name = "locksAutomatically")
    protected Boolean locksAutomatically;
    @XmlAttribute(name = "processingDelay")
    protected Duration processingDelay;
    @XmlAttribute(name = "proceedAspectDelay")
    protected Duration proceedAspectDelay;
    @XmlAttribute(name = "signalClosureDelay")
    protected Duration signalClosureDelay;
    @XmlAttribute(name = "approachReleaseDelay")
    protected Duration approachReleaseDelay;
    @XmlAttribute(name = "residualRouteReleaseDelay")
    protected Duration residualRouteReleaseDelay;
    @XmlAttribute(name = "priorityRank")
    protected BigInteger priorityRank;

    /**
     * Gets the value of the handlesRouteType property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the handlesRouteType property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHandlesRouteType().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getHandlesRouteType() {
        if (handlesRouteType == null) {
            handlesRouteType = new ArrayList<EntityILref>();
        }
        return this.handlesRouteType;
    }

    /**
     * Gets the value of the routeActivationSection property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the routeActivationSection property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRouteActivationSection().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RouteActivationSection }
     * 
     * 
     */
    public List<RouteActivationSection> getRouteActivationSection() {
        if (routeActivationSection == null) {
            routeActivationSection = new ArrayList<RouteActivationSection>();
        }
        return this.routeActivationSection;
    }

    /**
     * Gets the value of the facingSwitchInPosition property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the facingSwitchInPosition property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFacingSwitchInPosition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SwitchAndPosition }
     * 
     * 
     */
    public List<SwitchAndPosition> getFacingSwitchInPosition() {
        if (facingSwitchInPosition == null) {
            facingSwitchInPosition = new ArrayList<SwitchAndPosition>();
        }
        return this.facingSwitchInPosition;
    }

    /**
     * Gets the value of the trailingSwitchInPosition property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the trailingSwitchInPosition property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getTrailingSwitchInPosition().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SwitchAndPosition }
     * 
     * 
     */
    public List<SwitchAndPosition> getTrailingSwitchInPosition() {
        if (trailingSwitchInPosition == null) {
            trailingSwitchInPosition = new ArrayList<SwitchAndPosition>();
        }
        return this.trailingSwitchInPosition;
    }

    /**
     * Gets the value of the hasTvdSection property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the hasTvdSection property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasTvdSection().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getHasTvdSection() {
        if (hasTvdSection == null) {
            hasTvdSection = new ArrayList<EntityILref>();
        }
        return this.hasTvdSection;
    }

    /**
     * Gets the value of the routeEntry property.
     * 
     * @return
     *     possible object is
     *     {@link RouteEntry }
     *     
     */
    public RouteEntry getRouteEntry() {
        return routeEntry;
    }

    /**
     * Sets the value of the routeEntry property.
     * 
     * @param value
     *     allowed object is
     *     {@link RouteEntry }
     *     
     */
    public void setRouteEntry(RouteEntry value) {
        this.routeEntry = value;
    }

    /**
     * Gets the value of the intermediateCodePoint property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the intermediateCodePoint property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getIntermediateCodePoint().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getIntermediateCodePoint() {
        if (intermediateCodePoint == null) {
            intermediateCodePoint = new ArrayList<EntityILref>();
        }
        return this.intermediateCodePoint;
    }

    /**
     * Gets the value of the hasReleaseGroup property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the hasReleaseGroup property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getHasReleaseGroup().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EntityILref }
     * 
     * 
     */
    public List<EntityILref> getHasReleaseGroup() {
        if (hasReleaseGroup == null) {
            hasReleaseGroup = new ArrayList<EntityILref>();
        }
        return this.hasReleaseGroup;
    }

    /**
     * Gets the value of the switchPositionInDepartureTrack property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the switchPositionInDepartureTrack property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSwitchPositionInDepartureTrack().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link SwitchAndPosition }
     * 
     * 
     */
    public List<SwitchAndPosition> getSwitchPositionInDepartureTrack() {
        if (switchPositionInDepartureTrack == null) {
            switchPositionInDepartureTrack = new ArrayList<SwitchAndPosition>();
        }
        return this.switchPositionInDepartureTrack;
    }

    /**
     * Gets the value of the routeExit property.
     * 
     * @return
     *     possible object is
     *     {@link RouteExit }
     *     
     */
    public RouteExit getRouteExit() {
        return routeExit;
    }

    /**
     * Sets the value of the routeExit property.
     * 
     * @param value
     *     allowed object is
     *     {@link RouteExit }
     *     
     */
    public void setRouteExit(RouteExit value) {
        this.routeExit = value;
    }

    /**
     * Gets the value of the additionalRelation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a <CODE>set</CODE> method for the additionalRelation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAdditionalRelation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RelationReference }
     * 
     * 
     */
    public List<RelationReference> getAdditionalRelation() {
        if (additionalRelation == null) {
            additionalRelation = new ArrayList<RelationReference>();
        }
        return this.additionalRelation;
    }

    /**
     * Gets the value of the locksAutomatically property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isLocksAutomatically() {
        return locksAutomatically;
    }

    /**
     * Sets the value of the locksAutomatically property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setLocksAutomatically(Boolean value) {
        this.locksAutomatically = value;
    }

    /**
     * Gets the value of the processingDelay property.
     * 
     * @return
     *     possible object is
     *     {@link Duration }
     *     
     */
    public Duration getProcessingDelay() {
        return processingDelay;
    }

    /**
     * Sets the value of the processingDelay property.
     * 
     * @param value
     *     allowed object is
     *     {@link Duration }
     *     
     */
    public void setProcessingDelay(Duration value) {
        this.processingDelay = value;
    }

    /**
     * Gets the value of the proceedAspectDelay property.
     * 
     * @return
     *     possible object is
     *     {@link Duration }
     *     
     */
    public Duration getProceedAspectDelay() {
        return proceedAspectDelay;
    }

    /**
     * Sets the value of the proceedAspectDelay property.
     * 
     * @param value
     *     allowed object is
     *     {@link Duration }
     *     
     */
    public void setProceedAspectDelay(Duration value) {
        this.proceedAspectDelay = value;
    }

    /**
     * Gets the value of the signalClosureDelay property.
     * 
     * @return
     *     possible object is
     *     {@link Duration }
     *     
     */
    public Duration getSignalClosureDelay() {
        return signalClosureDelay;
    }

    /**
     * Sets the value of the signalClosureDelay property.
     * 
     * @param value
     *     allowed object is
     *     {@link Duration }
     *     
     */
    public void setSignalClosureDelay(Duration value) {
        this.signalClosureDelay = value;
    }

    /**
     * Gets the value of the approachReleaseDelay property.
     * 
     * @return
     *     possible object is
     *     {@link Duration }
     *     
     */
    public Duration getApproachReleaseDelay() {
        return approachReleaseDelay;
    }

    /**
     * Sets the value of the approachReleaseDelay property.
     * 
     * @param value
     *     allowed object is
     *     {@link Duration }
     *     
     */
    public void setApproachReleaseDelay(Duration value) {
        this.approachReleaseDelay = value;
    }

    /**
     * Gets the value of the residualRouteReleaseDelay property.
     * 
     * @return
     *     possible object is
     *     {@link Duration }
     *     
     */
    public Duration getResidualRouteReleaseDelay() {
        return residualRouteReleaseDelay;
    }

    /**
     * Sets the value of the residualRouteReleaseDelay property.
     * 
     * @param value
     *     allowed object is
     *     {@link Duration }
     *     
     */
    public void setResidualRouteReleaseDelay(Duration value) {
        this.residualRouteReleaseDelay = value;
    }

    /**
     * Gets the value of the priorityRank property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getPriorityRank() {
        return priorityRank;
    }

    /**
     * Sets the value of the priorityRank property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setPriorityRank(BigInteger value) {
        this.priorityRank = value;
    }

}
